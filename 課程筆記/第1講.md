###### tags: `黃能富計算機網路`
#  第1講
## 1.網址

![](https://hackmd.io/_uploads/Bk5cjWcV3.png)
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/40ca61e4-1843-4a7a-b902-2b9c763cf646)
---
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/4ff173e5-65c1-432b-8057-4e93a79371ed)




# URL
就是網址(domain name)
任何應用給別人使用是透過瀏覽器的方式就必須要有URL

# HTTP
URL base on HTTP
專門為瀏覽器設計的protocal

# TCP
HTTP 又base on TCP
提供建立連線
用TCP建立連線，是可靠的，封包可能遺失或丟棄，TCP會想辦法，使再傳一次，務必會讓封包傳過去

# 如果要上一個網站，會出現17個封包
1.6個封包透過URL網址查這個domain name的IP是甚麼，因為TCP要有IP

2.用TCP用3個封包來回建立連線

3.用HTTP要求要在這個網站拿甚麼

4.離開時要把這個TCP的連線取消

## 2.網路連接
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/bafdecb9-a9fe-494a-925e-9b3770c6f9f2)

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/339efc17-32bb-48b1-913a-accecbd8b42d)



# link
設備間連接的方式

# Node
就是設備，switch,router也是

# point to point
如果link連接的對象只有兩個，就是point to point

# multiple access
多設備連接
每個設備都聽得到傳輸的東西，多設備可access

# switched network
用switch把很多設備連起來的區域網路

# message,packet
原始的資料叫做message，因為太大太長，所以要切成packet(封包)為單位來傳輸

# store and forward
先把封包儲存，查表(在router或switch)看這個封包要給誰，再傳輸

---
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/81c5be09-0bef-4730-b085-0bffa1905dfe)
# Hosts
電腦(主機)
# Switches
讓封包在各主機傳輸的交換器
# Spanning tree
在傳輸的時候會建構spanning tree(途中的紅線，唯一的路徑)，使不產生迴路發生錯誤或延遲
# Internetwork
把很多網路再連接起來(圖下)
(a)是一個區域網路
(b)就是把很多網路都連起來
# Router/gateway
把網路連起來的設備為router
# Host-to-host connectivity
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/911e2c30-35aa-4a6a-9d3a-0f40d6d623d4)

兩台主機通訊
網路的最邊邊(主機)連接，把兩個非常遠的host連接起來就叫做host to host
# Address
每個電腦或網卡都有一個address
電腦主機位置叫做IP
網卡主機叫做mac address
# Routing
找到一個路徑把封包傳給對方

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/5b702c7e-7554-4775-9a0d-eb7a0f99bfea)

像這個可能有兩條路徑，要走哪一條
找一個最好的路徑，叫routing
# Unicast/broadcast/multicast
Unicast:封包只給一個對象
multicast:封包給一群對象
broadcast:封包給所有人，通常只在區域網路，因為router會把broadcase擋住，否則很容易就把所有網路癱瘓
# Local Area Networks
區域網路
短距離區域性的連接網路
# Metropolitan Area Networks
一個大到都市範圍的網路
# Wide Area Networks
涵蓋範圍更大的網路

## 3.封包怎麼在網路傳輸
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/33e24e5f-e7ff-4afc-9ad8-3093d3ed80d6)
封包會走哪一條路是不一定的，因為會因壅塞使有效率，或link斷掉繞不同的路

router平時就會溝通，說哪些雍塞等等，會根據當時狀況讓封包走不同的路

router也可把大封包拆成小封包傳輸，因為任何網路都有封包最大值，不同網路不一樣，切成小封包才能進去 比較小的封包最大值的網路傳輸

封包可能會因為壅塞所以在裡面繞來繞去，router就會把封包丟掉
internet是盡可能傳送封包，但可能會掉，太多封包在裡面等待傳輸，傳不出去也可能丟掉
如果很重要，就用TCP

# 4 網路上資源如何共享
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/0d47ab4d-8ba9-40f3-9767-0c5cce09e6ab)
只有一個link，中間的link如何分配讓3個封包傳輸呢

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/6ba16e38-ad7c-4a90-8d21-a5e8337a8777)
Frequency Division Multiplexing(FDM):
假設把頻寬切成4等份，4個user都可傳輸，但速度慢四倍

Synchronous Time-division Multiplexing (TDM):
輪流讓每個user傳輸，每次就是每個user占用整個頻寬

>這兩個都會造成負載不平衡時，不可以互相借用造成效率不均的問題，解決方式在下面

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/9f04768e-095d-479c-928f-7316e493d1ca)
用排程來解決
但是當壅塞的時候，還是會將封包丟棄

# 5
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/dd99c7f7-78d6-4064-b9a7-c7d9f35bd62c)
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/b8ec76ac-ce58-469c-8489-669f60ea25a2)

# 6 網路架構
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/3f9a4f8a-dd7e-4922-a151-fa292e564d9c)
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/9c116594-6ecd-4cae-b1c1-c32da29b8edb)
>網路分層簡單的架構
>先硬體就是要通訊的主要部分
>再來就是主機要互相連接
>再來是上面的process的連接通道
>之後就是應用程式

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/6dfbdc2d-75fc-4707-ae49-e813d9cd6378)

這地方講得很好，可以重看
>因為網路是把主機和設備溝通，各設備要怎麼看得懂對方封包，所以要制定那個封包的格式，還有傳送的流程和操作，就是一種雙方通訊的協議，沒有協議可能就會看不懂封包或解讀錯誤。

>protocal有分同主機不同層的溝通(前面說的分層溝通，每層是用下一層提供的服務，加一些東西給上層)，也有分不同主機的溝通(peer to peer,點對點)
>IP,TCP都是protocal，TCP根據IP

>在這個Layer的結構下，每一個protocal都是透過下層的服務經過加值提供給上層
>例:TCP提供可靠傳輸服務，Base on IP傳輸，IP不可靠，TCP是在不可靠的環境下提供可靠的服務

**互聯網工程任務組
(IETF: Internet Engineering Task Force) 
負責定義互聯網標準與協議規格**

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/ff5cf41b-3817-45ff-9772-723a9c670006)
>TCP透過IP建立連線，FTP(檔案傳輸)需要可靠的連線，所以使用TCP
>根據不同需求用不同protocal

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/83c69593-0603-47fa-87a0-082da313a035)
>兩台主機檔案傳輸建立的協議
>只要進到internet就是不可靠，封包可能會掉，TCP解決這樣的問題，下面網路怎麼搞亂掉，TCP都會負責

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/ee3b3548-af54-4379-97b9-35fb54d6f90d)

# 7 訊息封裝

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/105f4137-0360-46af-85f6-ba7e7585ba23)
>這個圖為左邊主機的應用程式要傳送Data到右邊主機的應用程式
>因為前面說的protocal的layer不只左右peer to peer也有同主機上下的layer

>所以流程為傳到TCP時，為了讓之後船過去到TCP階段時對方能夠解讀，要在data前面加header，之後對方TCP才能夠解讀，之後的IP也是，這個左邊加header的方式稱為encapsulation

>之後到對面header一層一層解讀
例:IP解讀header是誰送的等等，IP的header拿掉，TCP解讀header的連線過程，這個連線是建連線的封包?還是甚麼截除連線的封包? 
這個反過來拆的過程稱為decapsulation

# 8 介紹 OSI
所謂的OSI，是由國際化標準組織（ISO）針對開放式網路架構所制定的電腦互連標準，全名是開放式通訊系統互連參考模型（Open System Interconnection Reference Model），簡稱OSI模型。
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/dcb1cbd9-a813-4310-a791-6be43497e29a)

## data link
談的是送給下一個設備

## Network
談的是送的一整段網路給最遠的目的地，怎麼送，要走甚麼路線

## Transport
使用不同應用程式有不同的需求，可能需要非常可靠或不用很可靠(video)，這些負責把資料送給對方的傳輸服務
也就是TCP或UDP...
>兩端的host才有這段(看圖)

# 9 主機或電腦怎麼跟router和switch連接

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/7a8be083-0ffc-4fbe-8ba3-b55b4ad35f9f)
Network是看IP位址
Data Link是看網卡位址
>如果該設備送的時候是看IP位址，稱這設備為Layer2的設備(OSI從下往上第2，此設備根據Layer2做處理)
>如果該設備送的時候是看網卡位址，稱這設備為Layer3的設備
>有能力處理到哪一層就是Layer多少的設備(有可能可有Data Link和Network的能力此為Layer3)

Switch應該是之前玩電腦插網路線那台
中間通常會連接switch(區域網路)，其中的Data Link的header是看網卡的位置，在圖中最後的physical header會有此主機的網卡位址加上要傳送到的switch的網卡位址(才知道要傳到哪)，其中也包含最終目的地位址，之後switch收到會透過這個位址進行轉送
>注意，此講的是主機連有線網路的方式，是用乙太網路


>如果主機連無線網路是連AP，如下
>![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/69986def-ef9a-4d49-87e5-48ce19780d29)
>但再連出去也是可以用有線網路的
>主機在區域網路連有線網路出去是乙太網路
>連無線網路出去叫做wifi

# 10 開始講OSI各層的詳述-Physical Layer-Layer 1

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/df73cfb0-c71d-4df2-8f16-cf8a96a246c0)
>在談的是如何將資料用無線或有線網路的方式傳播

>資料用bit傳輸(coding)(用高低電位 判斷)，還要規定多久為1bit(兩邊的頻率相同)

# 11 Data Link Layer-Layer 2
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/8fd63927-0eee-4d1c-b73b-78f9432570bf)

**談的是如何將frame傳給直接相連的主機或設備**
>frame是Data Link Layer的header加上封包而已

>例如在multiple access時，多台電腦共用link，同時送data會錯誤，需要處理何時送,怎麼送

## 所以在Data Link Layer要制定一個MAC Protocal來決定怎麼傳輸

最常見的兩個protocal:

先看有沒有人在送，沒人送才能送

**CSMA/CD**

有線網路使用的協議

**CSMA/CA**

無線網路使用的協議

>每個網路都有一個MAC protocal

# 12 Network Layer-Layer 3
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/cc51a9c6-d3ad-4cc2-a709-3dce957aa8cf)
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/72b74de2-70cc-41c0-b223-06eda88704a2)


**談的是如何將封包透過Internet 送給目的地主機**

要選擇路線，而router之間可交換情報，要怎麼講話，就需要一個protocal制定他們怎麼溝通，稱為**routing protocal**

router之間會利用那些protocal定期交換情報，去算整個路徑，放到一個routing table，每個router都有，但都不一樣，因為router都不一樣
>因網路隨時變化，去更改routing table是依靠protocal交換訊息的功能去改變

1.RIP(第一代)
每三十秒交換狀態，太慢

2.OSPF(第二代)
找最短路徑傳輸(有分時間最短和距離最短)，每個router會知道到各node的最短路徑，如果路線有斷線，則

流程:
當router收到封包，因router是layer 3，先查看header，看destination IP知道要送到哪，再去查routing table要怎麼送

# 13 14 Transport Layer以上所有層介紹
## Transport Layer
提供不同主機processes(相當於應用程式)之間的資料傳送

將資料編號，主機互相通訊有沒有收到此編號的封包

此層一般只在host端才有，因為就是確認host雙方有無收到
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/65f4dea5-5010-4457-8b95-93684c677b7b)

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/d0bd7bc0-7be5-45a9-8e85-f25f104bb641)
看需求選擇protocal
>TCP-提供可靠的傳輸服務  
>ex:檔案不可遺失

>UDP-不可靠  
>ex:影片遺失一點也可以看

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/3bc61446-4e1a-43f6-91a6-1c74f1ad89b4)
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/56edac72-a6fc-4c45-854b-f1cd00c9ec33)

## Session Layer
像是p2p有很多host用TCP連接
把很多不同的Transport Layer stream整理再一起 

## Presentation Layer
怎麼呈現資料的格式
兩邊交換的資料用甚麼格式
ex:big5-中文?英文?

## Application Layer
使用的各種軟體和應用程式
用甚麼應用程式交換資料


![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/684cf1bd-3444-44e9-bfab-23782f5eb30b)
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/32b37a53-c773-4622-ac57-95f45d4e0b54)

>OSI每Layer都有不同的protocal，這些protocal由誰制定

>層和層的關係不用這麼嚴格，也可以跳過好幾層跟下面的進行溝通

>一般會把上三層結合在一起為Application，可直接呼叫TCP或IP或MAC ADDRESS(如果兩台電腦有連接，不需要IP)也可

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/b4c21da2-e586-42e2-ae9c-4038dbdabb99)


# 15 評估網路的效能>>頻寬和延遲

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/f1579134-62e1-47e1-8783-f7a2523343ec)

## 頻寬是在通訊Link中一秒可以傳送的bit數

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/4b1c4b3b-782b-432a-9a12-901c956d33ff)


因為速度越快，寬度越窄，收端要在1bit的中間去取樣，很難抓，容易有偏差，所以高速很難做

## 延遲(latency)
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/faf1cb58-9ee1-43c5-aa6b-7a70c312adba)
>latency=距離過去時間+傳輸bit的時間+在queue中等待的時間(雍塞)

>會先排隊等待傳輸>>傳輸一個一個bit到link上(傳輸bit的時間)>>在link上傳輸(距離過去時間)

>如資料bit少，但傳輸距離長，有可能bit傳輸完，第一個bit都還沒傳到對方(延遲)，這時距離過去時間就很重要
>
>反之自己推

# 16 延遲乘頻寬，throughtput
![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/898b81ab-1ea7-4962-b85c-70516e10e4ea)

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/6c591723-ed84-4cb9-8784-157878912d95)

![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/6bccdd6d-7638-4ef4-94cd-43d30301af0b)

>latency乘頻寬是資料在網路上的量，而網路傳輸需要等對方回應，傳完之後需要等對方回應，所以有分為傳輸bit的時間+對方回應的時間(過去+回來距離)，所以在等回應之前應該要盡可能送多一點的資料(要盡量送到latency乘頻寬的量，而不是latency乘頻寬盡量大)


![image](https://github.com/ShangZheTsai/NTHU-ocw-computer-network/assets/107501046/f9762c57-651b-4018-a4bc-3ac84978cfe3)
看下方的圖就好
>throughtput是在時間內傳輸了多少資料量
>
>=傳送端發送的資料量(要盡可能達到latency乘頻寬)/transfertime
>
>如時間內傳輸資料越多，傳輸封包大小越大，也就是thoughtput越大
